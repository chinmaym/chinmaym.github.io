<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Chinmay Mishra</title>
    <link>https://www.chinmaymishra.me/categories/leetcode/</link>
    <description>Recent content in Leetcode on Chinmay Mishra</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 03 Dec 2020 23:43:57 -0800</lastBuildDate><atom:link href="https://www.chinmaymishra.me/categories/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>December_day_3</title>
      <link>https://www.chinmaymishra.me/leetcode/december_day_3/</link>
      <pubDate>Thu, 03 Dec 2020 23:43:57 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/december_day_3/</guid>
      <description>Leetcode December Challege Day 3 Link to the question
Solution to the question
# Definition for a binary tree node. # class TreeNode(object): # def __init__(self, val=0, left=None, right=None): # self.val = val # self.left = left # self.right = right class Solution(object): def increasingBST(self, root): &amp;#34;&amp;#34;&amp;#34; :type root: TreeNode :rtype: TreeNode &amp;#34;&amp;#34;&amp;#34; if root == None: return None left = self.increasingBST(root.left) if left == None: head = root else: head = left while left and left.</description>
    </item>
    
    <item>
      <title>346_moving_average_from_data_stream</title>
      <link>https://www.chinmaymishra.me/leetcode/346_moving_average_from_data_stream/</link>
      <pubDate>Wed, 02 Dec 2020 23:19:39 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/346_moving_average_from_data_stream/</guid>
      <description>Leetcode 346 Given a stream of integers and a window size, calculate the moving average of all integers in the sliding window. Example: MovingAverage m = new MovingAverage(3); m.next(1) = 1 m.next(10) = (1 + 10) / 2 m.next(3) = (1 + 10 + 3) / 3 m.next(5) = (10 + 3 + 5) / 3 My solution -
class MovingAverage: def __init__(self, size: int): &amp;#34;&amp;#34;&amp;#34; Initialize your data structure here.</description>
    </item>
    
    <item>
      <title>1021_remove_outermost_parentheses</title>
      <link>https://www.chinmaymishra.me/leetcode/1021_remove_outermost_parentheses/</link>
      <pubDate>Wed, 02 Dec 2020 23:16:16 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1021_remove_outermost_parentheses/</guid>
      <description>Leetcode 1021 Link to the question
A valid parentheses string is either empty (&amp;#34;&amp;#34;), &amp;#34;(&amp;#34; + A + &amp;#34;)&amp;#34;, or A + B, where A and B are valid parentheses strings, and + represents string concatenation. For example, &amp;#34;&amp;#34;, &amp;#34;()&amp;#34;, &amp;#34;(())()&amp;#34;, and &amp;#34;(()(()))&amp;#34; are all valid parentheses strings. A valid parentheses string S is primitive if it is nonempty, and there does not exist a way to split it into S = A+B, with A and B nonempty valid parentheses strings.</description>
    </item>
    
    <item>
      <title>December_day_2</title>
      <link>https://www.chinmaymishra.me/leetcode/december_day_2/</link>
      <pubDate>Wed, 02 Dec 2020 23:10:08 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/december_day_2/</guid>
      <description>Leetcode December Challenge Day 2 Link to the question
Solution to the question
import random class Solution: def __init__(self, head: ListNode): &amp;#34;&amp;#34;&amp;#34; @param head The linked list&amp;#39;s head. Note that the head is guaranteed to be not null, so it contains at least one node. &amp;#34;&amp;#34;&amp;#34; self.head = head self.length = None def getRandom(self) -&amp;gt; int: &amp;#34;&amp;#34;&amp;#34; Returns a random node&amp;#39;s value. &amp;#34;&amp;#34;&amp;#34; head = self.head if self.length == None: self.</description>
    </item>
    
    <item>
      <title>1470_shuffle_the_array</title>
      <link>https://www.chinmaymishra.me/leetcode/leetcode/</link>
      <pubDate>Wed, 02 Dec 2020 18:36:57 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/leetcode/</guid>
      <description>Leetcode 1470 Link to the question
Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn]. Example 1: Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3: Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] My Solution -</description>
    </item>
    
    <item>
      <title>December_week_1_bonus</title>
      <link>https://www.chinmaymishra.me/leetcode/december_week_1_bonus/</link>
      <pubDate>Wed, 02 Dec 2020 01:21:46 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/december_week_1_bonus/</guid>
      <description>Leetcode December Challenge Day 1 Link to the question
Solution
class Solution(object): def shortestDistance(self, words, word1, word2): &amp;#34;&amp;#34;&amp;#34; :type words: List[str] :type word1: str :type word2: str :rtype: int &amp;#34;&amp;#34;&amp;#34; val1 = val2 = None dist = len(words) for i in range(len(words)): if words[i] == word1: val1 = i if words[i] == word2: val2 = i if val1 != None and val2 != None: dist = min(dist,abs(val1-val2)) return dist </description>
    </item>
    
    <item>
      <title>December_day_1</title>
      <link>https://www.chinmaymishra.me/leetcode/december_day_1/</link>
      <pubDate>Wed, 02 Dec 2020 01:10:00 -0800</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/december_day_1/</guid>
      <description>Leetcode December Challenge Day 1 Link to the question
Solution to the question
class Solution(object): def maxDepth(self, root): &amp;#34;&amp;#34;&amp;#34; :type root: TreeNode :rtype: int &amp;#34;&amp;#34;&amp;#34; if root is None: return 0 return 1+ max(self.maxDepth(root.left), self.maxDepth(root.right)) </description>
    </item>
    
    <item>
      <title>1_two_sum</title>
      <link>https://www.chinmaymishra.me/leetcode/leetcode/</link>
      <pubDate>Sat, 24 Oct 2020 13:00:07 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/leetcode/</guid>
      <description>Leetcode 1 Link to the question
Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target. You may assume that each input would have exactly one solution, and you may not use the same element twice. You can return the answer in any order. Example 1: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Output: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
    
    <item>
      <title>1389_create_target_array_in_given_order</title>
      <link>https://www.chinmaymishra.me/leetcode/1389_create_target_array_in_given_order/</link>
      <pubDate>Fri, 17 Apr 2020 01:44:26 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1389_create_target_array_in_given_order/</guid>
      <description>Leetcode 1389 Link to the question
Given two arrays of integers nums and index. Your task is to create target array under the following rules: Initially target array is empty. From left to right read nums[i] and index[i], insert at index index[i] the value nums[i] in target array. Repeat the previous step until there are no elements to read in nums and index. Return the target array. It is guaranteed that the insertion operations will be valid.</description>
    </item>
    
    <item>
      <title>Leetcode 904</title>
      <link>https://www.chinmaymishra.me/posts/leetcode_904/</link>
      <pubDate>Thu, 16 Apr 2020 14:51:36 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/posts/leetcode_904/</guid>
      <description>Leetcode 904 Solution [Link to the question] (https://leetcode.com/problems/fruit-into-baskets &amp;ldquo;Leetcode 904&amp;rdquo;)
In a row of trees, the i-th tree produces fruit with type tree[i]. You start at any tree of your choice, then repeatedly perform the following steps: Add one piece of fruit from this tree to your baskets. If you cannot, stop. Move to the next tree to the right of the current tree. If there is no tree to the right, stop.</description>
    </item>
    
    <item>
      <title>1342_number_of_steps_to_reduce_to_zero</title>
      <link>https://www.chinmaymishra.me/leetcode/1342_number_of_steps_to_reduce_to_zero/</link>
      <pubDate>Thu, 16 Apr 2020 01:59:14 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1342_number_of_steps_to_reduce_to_zero/</guid>
      <description>Leetcode 1342 Link to the question
Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Example 1: Input: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6.</description>
    </item>
    
    <item>
      <title>1403_minimum_subsequence_in_non_increasing_array</title>
      <link>https://www.chinmaymishra.me/leetcode/1403_minimum_subsequence_in_non_increasing_array/</link>
      <pubDate>Thu, 16 Apr 2020 01:55:48 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1403_minimum_subsequence_in_non_increasing_array/</guid>
      <description>Leetcode 1403 Link to the question
Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array.</description>
    </item>
    
    <item>
      <title>1394_find_lucky_integer_in_an_array</title>
      <link>https://www.chinmaymishra.me/leetcode/1394_find_lucky_integer_in_an_array/</link>
      <pubDate>Thu, 16 Apr 2020 01:51:56 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1394_find_lucky_integer_in_an_array/</guid>
      <description>Leetcode 1394 Link to the question
Given an array of integers arr, a lucky integer is an integer which has a frequency in the array equal to its value. Return a lucky integer in the array. If there are multiple lucky integers return the largest of them. If there is no lucky integer return -1. Example 1: Input: arr = [2,2,3,4] Output: 2 Explanation: The only lucky number in the array is 2 because frequency[2] == 2.</description>
    </item>
    
    <item>
      <title>1408_string_matching_in_an_array</title>
      <link>https://www.chinmaymishra.me/leetcode/1408_string_matching_in_an_array/</link>
      <pubDate>Wed, 15 Apr 2020 02:03:50 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1408_string_matching_in_an_array/</guid>
      <description>Leetcode 1408 Link to the question
Given an array of string words. Return all strings in words which is substring of another word in any order. String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j]. Example 1: Input: words = [&amp;#34;mass&amp;#34;,&amp;#34;as&amp;#34;,&amp;#34;hero&amp;#34;,&amp;#34;superhero&amp;#34;] Output: [&amp;#34;as&amp;#34;,&amp;#34;hero&amp;#34;] Explanation: &amp;#34;as&amp;#34; is substring of &amp;#34;mass&amp;#34; and &amp;#34;hero&amp;#34; is substring of &amp;#34;superhero&amp;#34;. [&amp;#34;hero&amp;#34;,&amp;#34;as&amp;#34;] is also a valid answer.</description>
    </item>
    
    <item>
      <title>1313_decompress Run Length Encoded List</title>
      <link>https://www.chinmaymishra.me/leetcode/1313_decompress-run-length-encoded-list/</link>
      <pubDate>Tue, 14 Apr 2020 02:10:42 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1313_decompress-run-length-encoded-list/</guid>
      <description>Leetcode 1313 Link to the question
We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair of elements [freq, val] = [nums[2*i], nums[2*i+1]] (with i &amp;gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list. Example 1: Input: nums = [1,2,3,4] Output: [2,4,4,4] Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2].</description>
    </item>
    
    <item>
      <title>1295_find Numbers With Even Number of Digits</title>
      <link>https://www.chinmaymishra.me/leetcode/1295_find-numbers-with-even-number-of-digits/</link>
      <pubDate>Tue, 14 Apr 2020 02:07:26 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1295_find-numbers-with-even-number-of-digits/</guid>
      <description>Leetcode 1295 Link to the question
Given an array nums of integers, return how many of them contain an even number of digits. Example 1: Input: nums = [12,345,2,6,7896] Output: 2 Explanation: 12 contains 2 digits (even number of digits). 345 contains 3 digits (odd number of digits). 2 contains 1 digit (odd number of digits). 6 contains 1 digit (odd number of digits). 7896 contains 4 digits (even number of digits).</description>
    </item>
    
    <item>
      <title>771_jewels_and_stone</title>
      <link>https://www.chinmaymishra.me/leetcode/771_jewels_and_stone/</link>
      <pubDate>Mon, 13 Apr 2020 03:02:11 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/771_jewels_and_stone/</guid>
      <description>Leetcode 771 Link to the question
You&amp;#39;re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so &amp;#34;a&amp;#34; is considered a different type of stone from &amp;#34;A&amp;#34;.</description>
    </item>
    
    <item>
      <title>69 sqrt</title>
      <link>https://www.chinmaymishra.me/leetcode/leetcode/</link>
      <pubDate>Mon, 13 Apr 2020 02:44:22 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/leetcode/</guid>
      <description>Link to the question
Implement int sqrt(int x). Compute and return the square root of x, where x is guaranteed to be a non-negative integer. Since the return type is an integer, the decimal digits are truncated and only the integer part of the result is returned. Example 1: Input: 4 Output: 2 Example 2: Input: 8 Output: 2 Explanation: The square root of 8 is 2.82842..., and since the decimal part is truncated, 2 is returned.</description>
    </item>
    
    <item>
      <title>1281_subtract the Product and Sum of Digits of an Integer</title>
      <link>https://www.chinmaymishra.me/leetcode/1281_subtract-the-product-and-sum-of-digits-of-an-integer/</link>
      <pubDate>Mon, 13 Apr 2020 02:12:28 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/1281_subtract-the-product-and-sum-of-digits-of-an-integer/</guid>
      <description>Leetcode 1281 Link to the question
Given an integer number n, return the difference between the product of its digits and the sum of its digits. Example 1: Input: n = 234 Output: 15 Explanation: Product of digits = 2 * 3 * 4 = 24 Sum of digits = 2 + 3 + 4 = 9 Result = 24 - 9 = 15 My solution -
func subtractProductAndSum(n int) int { prod := 1; sum := 0; for n &amp;gt;0 { rem := n % 10; sum += rem; prod *= rem; n /= 10; } return prod - sum; } </description>
    </item>
    
    <item>
      <title>665_non_decreasing_array</title>
      <link>https://www.chinmaymishra.me/leetcode/665_non_decreasing_array/</link>
      <pubDate>Sun, 12 Apr 2020 03:05:53 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/665_non_decreasing_array/</guid>
      <description>Leetcode 665 Link to the question
Given an array nums with n integers, your task is to check if it could become non-decreasing by modifying at most 1 element. We define an array is non-decreasing if nums[i] &amp;lt;= nums[i + 1] holds for every i (0-based) such that (0 &amp;lt;= i &amp;lt;= n - 2). Example 1: Input: nums = [4,2,3] Output: true Explanation: You could modify the first 4 to 1 to get a non-decreasing array.</description>
    </item>
    
    <item>
      <title>Intro</title>
      <link>https://www.chinmaymishra.me/leetcode/intro/</link>
      <pubDate>Sun, 12 Apr 2020 02:05:53 -0700</pubDate>
      
      <guid>https://www.chinmaymishra.me/leetcode/intro/</guid>
      <description>This is the start of my Leetcode challenge. I have recently been inspired to solve all the leetcode problems. I usually have these kind of latent interests of mine awakened by some some video that i saw on youtube or some blog that i read. I will try to solve as many questions as i can, I will be trying to solve atleast one a day.
I will start with easy ones and then transition into the medium and hard level questions.</description>
    </item>
    
  </channel>
</rss>
